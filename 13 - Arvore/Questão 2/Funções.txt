1. Operações na Árvore Binária de Busca (ABB):
a. Insere:
c
Copy code
void Insere(Registro x, Apontador *p) {
  if (*p == NULL) {
    *p = (Apontador)malloc(sizeof(Nodo));
    (*p)->Reg = x;
    (*p)->Esq = NULL;
    (*p)->Dir = NULL;
    return;
  }
  if (x.Chave < (*p)->Reg.Chave) {
    Insere(x, &(*p)->Esq);
  } else if (x.Chave > (*p)->Reg.Chave) {
    Insere(x, &(*p)->Dir);
  } else {
    printf("Registro existente na árvore.\n");
  }
}
Funcionamento:
A função recebe um registro x e um ponteiro para a raiz da árvore p.
Se a árvore está vazia, um novo nó é alocado para armazenar o registro x.
Se a árvore não está vazia, a função compara a chave de x com a chave do nó atual ((*p)->Reg.Chave) e decide se x deve ser inserido à esquerda ou à direita.
Se a chave já existe, uma mensagem é exibida indicando que o registro já está na árvore.
b. Pesquisa:
c
Copy code
void Pesquisa(Registro *x, Apontador p) {
  if (p == NULL) {
    printf("Erro: Registro não está na árvore.\n");
    return;
  }
  if (x->Chave < p->Reg.Chave) {
    Pesquisa(x, p->Esq);
  } else if (x->Chave > p->Reg.Chave) {
    Pesquisa(x, p->Dir);
  } else {
    *x = p->Reg;
  }
}
Funcionamento:
A função recebe um ponteiro para um registro x e um nó da árvore p.
Se o nó é nulo, significa que o registro não está na árvore, e uma mensagem de erro é exibida.
Se a chave de x é menor que a chave do nó atual, a busca continua na subárvore esquerda.
Se a chave de x é maior, a busca continua na subárvore direita.
Se a chave é igual, o registro é encontrado, e o ponteiro x é atualizado com o registro correspondente.
c. Retira:
c
Copy code
void Retira(Registro x, Apontador *p) {
  Apontador Aux;

  if (*p == NULL) {
    printf("Erro: Registro não está na árvore.\n");
    return;
  }
  if (x.Chave < (*p)->Reg.Chave) {
    Retira(x, &(*p)->Esq);
  } else if (x.Chave > (*p)->Reg.Chave) {
    Retira(x, &(*p)->Dir);
  } else {
    if ((*p)->Dir == NULL) {
      Aux = *p;
      *p = (*p)->Esq;
      free(Aux);
    } else if ((*p)->Esq != NULL) {
      Antecessor(*p, &(*p)->Esq);
    } else {
      Aux = *p;
      *p = (*p)->Dir;
      free(Aux);
    }
  }
}
Funcionamento:
A função recebe um registro x e um ponteiro para a raiz da árvore p.
Se a árvore está vazia, indica que o registro não está na árvore.
Se a chave de x é menor que a chave do nó atual, a busca continua na subárvore esquerda.
Se a chave de x é maior, a busca continua na subárvore direita.
Se a chave é igual, a função remove o nó. O tratamento é feito para três casos: nó folha, nó com apenas um filho, e nó com dois filhos.
2. Operações com Categorias:
a. InserirCategoria:
c
Copy code
void InserirCategoria(char nomeCategoria[20]) {
  Categoria *novaCategoria = (Categoria *)malloc(sizeof(Categoria));
  strcpy(novaCategoria->nome, nomeCategoria);
  novaCategoria->arvore = NULL;
  novaCategoria->proxima = NULL;

  if (floresta == NULL) {
    floresta = novaCategoria;
  } else {
    Categoria *tempCategoria = floresta;
    while (tempCategoria->proxima != NULL) {
      tempCategoria = tempCategoria->proxima;
    }
    tempCategoria->proxima = novaCategoria;
  }

  contadorCategorias++; 
}
Funcionamento:
A função recebe o nome de uma categoria.
Aloca dinamicamente uma nova categoria e a inicializa com o nome fornecido.
Se a floresta (lista de categorias) está vazia, a nova categoria se torna a primeira.
Se a floresta já possui categorias, a nova categoria é adicionada ao final da lista.
b. InserirNaCategoria:
c
Copy code
void InserirNaCategoria(Registro x, Categoria *categoria) {
  Insere(x, &(categoria->arvore));
}
Funcionamento:
A função recebe um registro x e um ponteiro para uma categoria.
Chama a função Insere para inserir o registro x na árvore associada à categoria.
c. PesquisarNaCategoria:
c
Copy code
void PesquisarNaCategoria(Registro *x, Categoria *categoria) {
  Pesquisa(x, categoria->arvore);
}
Funcionamento:
A função recebe um ponteiro para um registro x e um ponteiro para uma categoria.
Chama a função Pesquisa para pesquisar o registro x na árvore associada à categoria.
d. ExcluirDaCategoria:
c
Copy code
void ExcluirDaCategoria(Registro x, Categoria *categoria) {
  Retira(x, &(categoria->arvore));
}
Funcionamento:
A função recebe um registro x e um ponteiro para uma categoria.
Chama a função Retira para excluir o registro x da árvore associada à categoria.
3. Funções de Impressão:
a. ImprimirArvore:
c
Copy code
void ImprimirArvore(Apontador p, int nivel) {
  if (p == NULL) {
    return;
  }
  ImprimirArvore(p->Dir, nivel + 1);
  for (int i = 0; i < nivel; i++) {
    printf("   ");
  }
  printf("%d\n", p->Reg.Chave);
  ImprimirArvore(p->Esq, nivel + 1);
}
Funcionamento:
A função recebe um ponteiro para um nó p e um nível para controle da profundidade na árvore.
Utiliza recursão para percorrer a árvore na ordem inversa (da direita para a esquerda), imprimindo cada nó com a devida indentação.
